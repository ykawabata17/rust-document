# Rsutの勉強する
このリポジトリでは，Rustの勉強用に[The Rust Programming Language 日本語版](https://doc.rust-jp.rs/book-ja/title-page.html#the-rust-programming-language-%E6%97%A5%E6%9C%AC%E8%AA%9E%E7%89%88)を題材として，僕なりに勉強を進めていく．  
ここではテキストベースで勉強を進めていき，src内のプログラムでコードベースで進めていく．  
**知らないところやRust特有の概念などを勉強したいので，すでに知っている概念や書き方などは省略してある．**  

## 2章 数当てゲーム
ここでは，いきなりRustを実際に触っていく．  
プロジェクトの立ち上げ方は，立ち上げたいディレクトリ上で`cargo new (project_name)`を打ち込む．  
生成された *(project_name)/Cargo.toml* ファイルはプロジェクト全体の設定を行うファイルのようなもので， *(project_name)/src/main.rs* ファイルにコードを書いていく．
特に概念的な話はなく，ただコードを動かして楽しむだけの章なのでこれだけ．

## 3章 一般的な概念
他の言語にもあるような一般的なプログラミングの概念をRustで書くとどうなるのかを勉強する．

### 3.1 変数と可変性
変数を定義するときは`let`を用いる． 可変定数を定義するときは`mut`を用いる．
```rust
let x = 5;      // これは不変定数の定義
x = 6;          // 不変定数だからこれはコンパイルエラーになる
let mut y = 5;  // これは可変定数の定義
y = 6;          // 可変定数だから書き換え可能
```
不変定数を書き換える方法として，**覆い隠す**方法がある．
```rust
let x = 5;
x = x + 1;      // 不変定数の覆い隠し（実行可能)
let spaces = "   ";     // String型で，スペース3つ
spaces = spaces.len();  // 整数型でspacesの長さ(型が変わっても覆い隠しなら問題なし)
```
逆に，以下のコードはコンパイルエラーになる，面白い．
```rust
let mut spaces = "   ";   // 可変定数で同じように定義
spaces = spaces.len();    // コンパイルエラーになる
```

### 3.2 データ型
Rustは**静的型付け言語**である．つまり，コンパイル時に全ての変数の方が判明している必要がある．  
コンパイル時に複数の型を取り得る場合は型注釈を付けないとコンパイルエラーになるよ．(他にない概念でちょっと難しい)
```rust
let guess: u32 = "42".parse().expect("Not a number!");    // expectで型注釈を記載
```
この辺の概念はPythonしか基本触ってこなかった僕からしたらめんどくさいけど面白い．  
  
データ型については基本的に他の言語とそう変わらないので結構省略する．大事そうな部分だけピックアップ．  
* 基本的に，整数型は`i32(符号付き32bit)`，浮動小数点型は`f64(倍精度浮動小数点数)`を用いましょ．  
* 文字型`char`は**ユニコード**なので，アスキーよりもいっぱい文字を扱える(らしい)．詳しくは8章だって．  
* タプルの要素への参照にはなぜか`tuple.要素数`のように()や[]を用いない
```rust
let tup = (500, 4.1, 3);
let first = tup.0;    // 500
let second = tup.1;   // 4.1
```

### 3.3 関数
関数に関しても基本的に構文は一緒．  
返り値に`return`とか明記しないからそこだけ注意．  
```rust
// 関数の定義
// xとyを引数として足し合わせて返す関数
fn add_x_y(x: i32, y: i32) -> i32 {
    x+y     // 返り値にはreturnなどを明記しない(気持ち悪い)
}

fn main() {
    let add_num = add_x_y(3, 5);
    println!("3 + 5 is {}", add_num);
}
```
注意したいのは，返り値として記載してる`x+y`のところ．文末にセミコロンがないため**式**として認識される．これにセミコロンを足してしまうと**文**として認識されてコンパイルエラーになる．  
セミコロンの有無で式と文の違いを表現している．面白い．

### 3.5 制御フロー
if文とwhile文は基本的に一緒．  
for文が少し違ってて，`for ~ in ...`の書き方しかできない．まぁこの書き方もPythonにあるからわかる．  
初めてみたのは`loop{}`構文．ただひたすらに{}内をループするから，breakで抜けてあげないと無限ループしちゃう．

## 4章 所有権
この章は今までPythonしか使ってこなかった僕からしたらパッパラパーだった．  
でもRustを書いていくには避けては通れない概念なのでここはしっかり勉強しておきたい．

### 4.1 所有権について
RustにはGC(ガベージコレクション)がない！これは知ってる．  
まずはメモリの使用方法である，**スタック**と**ヒープ**について勉強する．  
スタックはこれまでにデータ構造で散々習ったことがあるし，単純な構造なので詳細を省くが，簡単に言うと「先入後出し，後に出したものから先に取る！」って感じ．終わり．  
ヒープは少し複雑なのでもう少し詳しく説明する．  

まず，ヒープとスタックは共に**一時的に確保されるメモリ領域**と言うことは覚えておく．
その上で，スタック領域には確保と解放に順番があるが，ヒープ領域には順番がない．つまり，**どのような順番で確保・開放するかはソフトウェア側で自由に決められる．**  

* とても大事なRustの所有権規則  
このルールを頭に入れながらこの章を見ていく
    * Rustの各値は，**所有者**と呼ばれる変数と対応している
    * いついかなるときも所有者は一つである
    * 所有者がスコープから外れたら値は破棄される

とりあえずこの節で言いたそうなことを自分なりにまとめた．
* 宣言した変数はそのスコープを抜けたら自動的に`drop`されて所有権を失う(つまりそれ以降はその変数を使えない)
* String型の変数を他の変数に代入したら元の変数の所有権が`ムーブ`して元の変数はそれ以降使えなくなる
* もし同じような変数として使いたい場合は`.clone()`メソッドを使う
* 関数を使う時も一緒で，引数として渡したらその関数内の引数に所有権がムーブする
* 同様に，返り値も返された変数に所有権がムーブする

**[ここが超重要]**  
とにかく所有権は一つの変数につき1個だけ！  

まぁコードを実際に自分で確かめた方がわかりやすかったから実際にやってみた方がいい．面白かった．

### 4.2 参照と借用
まず参照と借用の言葉の定義についてまとめておく．
> **参照(reference)** とはオブジェクト(変数やら配列やらなんやら)が存在している場所(メモリ上のアドレス)を指し示すもの  

> **借用とは** 所有権を移さずに変数の中身をレンタルすること  

参照についてはなんとなくイメージを掴めてるから，借用について詳しく説明していく．  
その前に，**イミュータブル**と**ミュータブル**について説明していく．  
イミュータブルな変数というのは，変数を作った後に変数の中身を変更できない，要するに不変変数．逆に，ミュータブルな変数は後から変数の中身を変更できる，要するに可変変数．  
これからはこっちの言い方に変える．(かっこいいから，，，)  
ここで初めて可変変数には`mut`をつける意味がわかった．ミュータブルの意味やったのね．  

では，借用についてみていく．借用には以下の3つのルールがある．
* イミュータブルな借用であれば複数可能
* ミュータブルな借用であれば1つしかできない
* イミュータブルな借用とミュータブルな借用は同時にできない  

要するに以下のコードのような感じ
```rust
// イミュータブルな借用なので複数可能
let a_imut = String::from("hello");
let b = &a_imut;
let c = &a_imut;

// ミュータブルな借用なので1つだけ
let mut a_mut = String::from("hello");
let b = &mut a_mut;     // ここではエラーにならない
let c = &mut a_mut;     // ここでエラーになる

// 借用は同時にできない
let mut a = String::from("hello");
let b = &mut a;
let c = &a;         // ここでエラーになる
```

また，関数の借用でも引数に対して所有権の移動がないため，関数内のスコープが終了してもその引数自体に所有権がなく，何も起きない．  

### 4.3 スライス型
スライスの概念は知ってる．`[~..~]`みたいな感じのやつ．  
使い方はこんな感じ
```rust
let s = String::from("hello world");
let hello = &s[0..5];
```
文字列リテラルはスライスであるため，String型でもstr型でも良い．  
結構複雑だと思ってたけど，前節の所有権とか参照とか頭に入ってたらすぐに理解できた．  

## 5章 構造体
構造体についてはこれまでもたくさん触れてきたけど，Rustの特有な表現などがあれば書いていく．
### 5.1 構造体の定義とインスタンス生成
この辺はプログラミングの初歩的な概念なのでスキップしていく．  
**構造体**はタプルと違い，データに対して名前をつけてあげる．このデータと名前が1対1の関係になっており，これを**フィールド**と呼ぶ．ミュータブルなインスタンスであれば，`.`(ドット)でフィールドの値を変更することもできる．  
よくある構造体の例を書いておく．
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```
**構造体更新記法**というものがあり，これを使用するとシンプルにインスタンスを作成することができる．
```rust
let user2 = User {
    email: String::from("user2@example.com"),
    username: String::from("username2"),
    ..user1     // 以下はuser1インスタンスと一緒という意味
};
```
あとは**タプル構造体**も結構珍しいからそれも説明しとく．  
文字で説明するのは結構難しそうだからコードで説明する．
```rust
// タプル構造体の定義
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
// 使い方
let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```
要するに，タプルにはない構造体名は持つけど，構造体にあるフィールドを持たない．みたいな？  
この例みたいに色の3値を示すときとか，3次元の場所を示すときとかに使えると思った．  

### 5.2 構造体の使用例
この節では特に新しい概念がなく，構造体を使用するべき場面などを説明しているだけなので，詳しい説明は[コード](https://github.com/ykawabata17/rust-document/blob/main/src/Chapter5/struct_example.rs)を見る．  
ただ，面白い概念が1つ出てきて，構造体のインスタンスの中身を出力してデバッグしたい時などがある．ところが，`println!("{}", instance);`などとしてもコンパイルエラーになってしまう．  
こんな時に使える機能が，**Debugトレイと**で，構造体を宣言しているところで`#[derive(Debug)]`をつけてやる．こんな感じ
```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
```
で，`println!("{:?}", instance)`のように記載すれば構造体のそのままの形で出力されるから，デバッグの時に使える!  
こんな機能が標準で備わってるのすごい

### 5.3 メソッド
今まで習ってきた僕の知識からすれば，メソッドはクラスの中で定義する関数みたいなもの．だったけどRustにはクラスがない!?  
実は，Rustはオブジェクト指向言語じゃなかった．ここまでずっと知らなかった．笑  
オブジェクト指向の三大要素！
* 隠蔽化
* 継承
* ポリモーフィズム  

Rustは隠蔽化とポリモーフィズムはサポートされているが，継承がない．だからオブジェクト指向とは言えないらしい．  
継承はないけど，**トレイト**とかいう概念があるらしい．これはまた勉強することになるでしょう．ということでパス．  
ということでメソッドに移っていく．メソッドの定義は`impl`(implementation;実装)ブロックの中で定義する．  
実際の実装方法については[コード](https://github.com/ykawabata17/rust-document/blob/main/src/Chapter5/method.rs)を見る．